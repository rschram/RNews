# app/app.R
library(shiny)
library(visNetwork)
library(tidyverse)
library(igraph)
library(Matrix)
library(text2vec)
library(here)
library(plotly)

# ==============================================================================
# 1. ROBUST PATHS (Fixes the "Missing File" Warning)
# ==============================================================================
source(here::here("config.R"))
source(here::here("R", "text_utils.R"))    # Highlighter
source(here::here("R", "graph_utils.R"))   # Graph Filter

# ==============================================================================
# 2. LOAD DATA (SMART LOADER)
# ==============================================================================

# A. LOAD MODEL (The DTM)
model <- readRDS(here::here("data", "app_ready", "model_current.rds"))

# B. LOAD VECTORS (Handle raw 'vectors_obj')
# We look for the file generated by your QMD script
vec_path <- here::here("data", "processed", "vectors.rds") 
if (!file.exists(vec_path)) vec_path <- here::here("data", "vectors.rds") # Fallback

if (file.exists(vec_path)) {
  raw_vecs <- readRDS(vec_path)
  
  # CASE 1: It's the "vectors_obj" LIST (Word Vectors + Metadata)
  if (is.list(raw_vecs) && !is.data.frame(raw_vecs) && "vectors" %in% names(raw_vecs)) {
    message(">> Found Word Vector Object. Calculating Document Vectors on the fly...")
    
    # 1. Extract Word Vectors
    word_matrix <- raw_vecs$vectors
    
    # 2. Extract Metadata (if you said it's in there!)
    if (!is.null(raw_vecs$meta)) {
      model$meta <- raw_vecs$meta
      message(">> Metadata extracted from vector object.")
    }
    
    # 3. Convert Word Vectors -> Document Vectors
    # Math: Doc_Vec = DTM (Docs x Words) * Word_Vecs (Words x Dim)
    common_vocab <- intersect(colnames(model$dtm), rownames(word_matrix))
    
    if (length(common_vocab) > 0) {
      dtm_aligned <- model$dtm[, common_vocab]
      wv_aligned  <- word_matrix[common_vocab, ]
      
      # The Magic Calculation
      vectors <- as.matrix(dtm_aligned %*% wv_aligned)
      message(sprintf(">> Calculated %d Document Vectors.", nrow(vectors)))
    } else {
      warning("No overlapping vocabulary between DTM and Word Vectors!")
      vectors <- NULL
    }
    
    # CASE 2: It's already a MATRIX (Document Vectors)
  } else if (is.matrix(raw_vecs) || is.data.frame(raw_vecs)) {
    vectors <- as.matrix(raw_vecs)
    message(">> Loaded pre-calculated Document Vectors.")
    
  } else {
    warning("vectors.rds loaded but format is unrecognized.")
    vectors <- NULL
  }
} else {
  warning("vectors.rds NOT FOUND. Falling back to DTM Word Counts.")
  vectors <- NULL
}

# C. LOAD METADATA (Fallback if not found in vectors)
if (is.null(model$meta)) {
  corpus_path <- here::here("data", "corpus.rds")
  if (file.exists(corpus_path)) {
    corpus_obj <- readRDS(corpus_path)
    if (is.data.frame(corpus_obj)) model$meta <- corpus_obj
    else if (!is.null(corpus_obj$meta)) model$meta <- corpus_obj$meta
  }
}




# ==============================================================================
# 3. PRE-CALCULATION (Layout & Metadata)
# ==============================================================================

if (igraph::vcount(model$graph) > 0) {
  message(">> Pre-calculating layout & attributes...")
  
  # A. Layout (DrL for speed)
  # Only calc if x/y don't exist yet
  if(is.null(igraph::V(model$graph)$x)) {
    coords <- igraph::layout_with_drl(model$graph, options=list(simmer.attraction=0))
    igraph::V(model$graph)$x <- coords[,1] * 100 
    igraph::V(model$graph)$y <- coords[,2] * 100
  }
  
  # B. Titles (Hover Tooltips)
  # This fixes the "doc_id" hover issue
  if (!is.null(model$meta)) {
    # Match graph IDs to metadata IDs
    # distinct() ensures we don't get duplicates if metadata is messy
    meta_distinct <- model$meta %>% dplyr::distinct(doc_id, .keep_all = TRUE)
    indices <- match(igraph::V(model$graph)$name, meta_distinct$doc_id)
    
    # Assign headlines
    titles <- meta_distinct$headline[indices]
    # Fill NAs with IDs
    titles[is.na(titles)] <- igraph::V(model$graph)$name[is.na(titles)]
    igraph::V(model$graph)$title <- titles
  } else {
    igraph::V(model$graph)$title <- igraph::V(model$graph)$name
  }
}


# ==============================================================================
# UI Styles
# ==============================================================================

fruit_salad_css <- "
  /* Base Highlight Box */
  .hl-base {
    position: relative;
    border-radius: 4px;
    padding: 2px 2px;
    margin: 0 1px;
    cursor: pointer;
    transition: all 0.2s;
    display: inline-block; /* Essential for the float behavior */
    line-height: 1.4;
  }

  /* Specific Groups */
  .hl-bursty { background-color: rgba(46, 204, 113, 0.2); border-bottom: 2px solid #2ecc71; }
  .hl-shared { background-color: rgba(52, 152, 219, 0.2); border-bottom: 2px solid #3498db; }
  .hl-query  { background-color: rgba(241, 196, 15, 0.3); border-bottom: 2px solid #f1c40f; }

  /* The 'Floated' Footnote Badge */
  .hl-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background-color: #333;
    color: white;
    font-size: 9px;
    font-weight: bold;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    text-align: center;
    line-height: 16px;
    z-index: 10;
    box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    display: none; /* Hidden by default */
  }

  /* Show badge on hover */
  .hl-base:hover .hl-badge {
    display: block;
  }

  /* Hover state for the box */
  .hl-base:hover {
    filter: brightness(0.95);
  }
"



# ==============================================================================
# UI
# ==============================================================================
ui <- fluidPage(
  tags$head(tags$style(fruit_salad_css)),
  
  titlePanel("Discourse graph workbench"),
  
  sidebarLayout(
    sidebarPanel(
      width = 3,
      # --- 1. SEARCH & FILTER ---
      h4("1. Search & Filter"),
      textInput("search_term", NULL, placeholder = "Search terms..."),
      checkboxGroupInput("highlights", "Highlight Layers:",
                         choices = c("Search Terms" = "query", "Bursty Words" = "bursty", "Shared (Edge)" = "shared"),
                         selected = c("bursty", "shared")),
      hr(),
      
      # --- 2. GRAPH METRICS (NEW) ---
      h4("2. Graph State"),
      uiOutput("live_metrics"), # <--- LIVE STATS HERE
      hr(),
      
      # --- 3. VIEW CONTROLS (Updated) ---
      h4("3. View Settings"),
      
      # Changed: "Backbone Density" instead of "Link Strength"
      # We limit this to 0% - 20% of extra edges to prevent hairballs.
      sliderInput("density_fraction", "Edge Density:", 
                  min = 0, max = 0.20, value = 0.05, step = 0.01, post = "%"),
      
      # Removed: "Re-Build Graph" button and "burst_percentile" slider
      # to enforce strict alignment with the offline model.
      div(class = "alert alert-info", style = "font-size: 11px;",
          icon("info-circle"), " Displaying fixed model topology.")
    ),
    
    mainPanel(
      width = 9,
      # SPLIT VIEW: GRAPH ON TOP, WORKBENCH BELOW
      
      # Top: The Graph
      div(style = "border-bottom: 2px solid #ddd; padding-bottom: 20px; margin-bottom: 20px;",
          visNetworkOutput("net_plot", height = "500px")
      ),
      
      # Bottom: The Workbench (Tabset)
      tabsetPanel(id = "workbench_tabs",
                  
                  # TAB A: SELECTION TABLE (New)
                  tabPanel("Selection Workbench", icon = icon("list"),
                           br(),
                           h4("Selected Documents & Edge Composition"),
                           p("Select 2+ nodes to see shared terms."),
                           tableOutput("selection_table") # <--- THE NEW TABLE
                  ),
                  
                  # TAB B: DOC VIEWER (Original)
                  tabPanel("Document Reader", icon = icon("file-alt"),
                           br(),
                           uiOutput("inspector_header"),
                           # Add the button here
                           downloadButton("download_transcript", "Download Transcript", class = "btn-sm"), 
                           hr(),
                           htmlOutput("doc_viewer")
                  ),
                  
                  # TAB C: VOCAB PLOT (Moved down)
                  tabPanel("Vocabulary Plot", icon = icon("chart-bar"),
                           plotlyOutput("vocab_plot", height = "500px")
                  )
      )
    )
  )
)

# ==============================================================================
# SERVER
# ==============================================================================
server <- function(input, output, session) {
  
  # --- A. DATA REACTIVES ---
  
  final_graph <- reactive({
    # Always return the offline model's graph
    # (Ensure your QMD saved the full graph, e.g. threshold 0.1 or 0.2)
    req(model$graph)
    return(model$graph)
  })
  
  # --- B. SEARCH LOGIC ---
  matched_docs <- reactive({
    req(input$search_term)
    term <- tolower(input$search_term)
    if (term %in% colnames(model$dtm)) {
      indices <- which(model$dtm[, term] > 0)
      return(rownames(model$dtm)[indices])
    }
    return(NULL)
  })
  

  # --- C. GRAPH RENDER (With Backbone) ---
  output$net_plot <- renderVisNetwork({
    req(final_graph())
    g <- final_graph()
    target_ids <- if(isTruthy(input$search_term)) matched_docs() else NULL
    
    # 1. Apply Backbone Filter
    # This keeps the MST (connectivity) + Top X% strongest edges (density)
    # It ensures all nodes remain visible (no isolates hidden) but renders fast.
    g_vis <- get_graph_backbone(g, keep_fraction = input$density_fraction)
    
    # 2. Prepare for VisNetwork
    vis_data <- prepare_visual_graph(g_vis, target_ids)
    
    visNetwork(vis_data$nodes, vis_data$edges) %>%
      visEdges(smooth = FALSE, width = 0.5, 
               color = list(color = "rgba(150,150,150, 0.4)", highlight = "black")) %>%
      
      # Node Styling
      visNodes(size = 30, shape = "dot", 
               color = list(background = "#97C2FC", border = "#2B7CE9", highlight = "#FF4040")) %>%
      
      visPhysics(enabled = FALSE) %>% 
      visInteraction(multiselect = TRUE, navigationButtons = TRUE, 
                     zoomView = TRUE, dragView = TRUE) %>%
      visEvents(select = "function(nodes) { Shiny.onInputChange('sel_node', nodes.nodes); }")
  })  
  # --- LIVE METRICS RENDERER ---
  output$live_metrics <- renderUI({
    g <- final_graph()
    stats <- get_graph_metrics(g)
    
    if (is.null(stats)) return(helpText("No graph data."))
    
    tagList(
      div(style = "font-size: 13px;",
          strong("Similarity model:", format(model$model_name)), br(),
          strong("Nodes:"), format(stats$Nodes, big.mark=","), br(),
          strong("GCR:"), sprintf("%.1f%%", stats$GCR * 100), br(),
          strong("Modularity:"), sprintf("%.3f", stats$Modularity), br(),
          strong("Transitivity:"), sprintf("%.3f", stats$Transitivity), br(),
          strong("Assortativity:"), sprintf("%.3f", stats$Assortativity)
      )
    )
  })
  
  # --- D. VOCAB PLOT (With Lines) ---
  output$vocab_plot <- renderPlotly({
    req(model$stats)
    
    # 1. Calculate the Threshold (The Red Line)
    # Slider (0.0 - 0.95): Represents % of generic words to cut.
    # High Slider = Low Threshold (Only keeping very negative "entropy gaps" (residuals) or bursty words)
    threshold_val <- quantile(model$stats$Entropy_Gap, 
                              probs = (1 - input$burst_percentile), 
                              na.rm = TRUE)
    
    # 2. Sort data for clean line drawing
    plot_data <- model$stats %>% arrange(Frequency)
    
    # 3. Build Plot
    plot_ly(plot_data, source = "vocab_plot") %>%
      
      # Layer A: The Dots (Words)
      add_markers(
        x = ~log10(Frequency), 
        y = ~Entropy, 
        text = ~paste("Term:", Term, 
                      "<br>Freq:", Frequency,
                      "<br>Entropy:", round(Entropy, 2),
                      "<br>Entropy gap:", round(Entropy_Gap, 2)),
        color = ~Entropy_Gap, 
        colors = "RdBu", # Blue = Bursty (Low Entropy_Gap), Red = Generic
        marker = list(opacity = 0.6, size = 6),
        name = "Words"
      ) %>%
      
      # Layer B: The "Null Model" (Gray Dashed Line)
      # This represents Entropy_Gap = 0 (Expected Entropy)
      add_lines(
        x = ~log10(Frequency),
        y = ~Expected_Entropy,
        line = list(color = "rgba(100,100,100,0.5)", dash = "dash", width = 2),
        name = "Expected Entropy",
        hoverinfo = "none",
        inherit = FALSE
      ) %>%
      
      # Layer C: The "Ablation Cutoff" (Moving Red Line)
      # This represents the threshold. Points BELOW this line are "Kept" (Bursty).
      add_lines(
        x = ~log10(Frequency),
        y = ~ (Expected_Entropy + threshold_val),
        line = list(color = "red", dash = "dot", width = 1),
        name = paste("Cutoff:", round(threshold_val, 2)),
        hoverinfo = "none",
        inherit = FALSE
      ) %>%
      
      layout(
        title = "Word Entropy vs. Frequency",
        xaxis = list(title = "Log10 Frequency"), 
        yaxis = list(title = "Entropy"),
        showlegend = FALSE
      )
  })
  
  # --- SELECTION WORKBENCH TABLE ---
  # --- SELECTION WORKBENCH TABLE (SCM Aware) ---
  output$selection_table <- renderTable({
    req(input$sel_node)
    sel <- input$sel_node
    
    # 1. Base Table
    df <- data.frame(
      Doc_ID = sel,
      Headline = NA_character_,
      Bursty_Topic = NA_character_,
      # Changed column name to reflect new logic
      SCM_Drivers = NA_character_, 
      stringsAsFactors = FALSE
    )
    
    # 2. Populate Rows
    for(i in seq_along(sel)) {
      doc_id <- sel[i]
      
      # A. Headline
      if (!is.null(model$meta)) {
        match_idx <- match(doc_id, model$meta$doc_id)
        df$Headline[i] <- if(!is.na(match_idx)) model$meta$headline[match_idx] else "(No Metadata)"
      }
      
      # B. Bursty Words (Top 3)
      terms <- names(which(model$dtm[doc_id,] > 0))
      top_words <- model$stats %>% 
        filter(Term %in% terms) %>%
        arrange(Entropy_Gap) %>% 
        head(3) %>%
        pull(Term) %>%
        paste(collapse = ", ")
      df$Bursty_Topic[i] <- top_words
      
      # C. SCM Decomposition (The New Logic)
      if (length(sel) == 2) {
        # Only compute pairwise explanation if exactly 2 docs selected
        other_id <- sel[setdiff(1:2, i)]
        
        # Check if we have vectors available for SCM
        if (!is.null(vectors)) {
          # Use the new utility function
          scm_breakdown <- get_scm_edge_breakdown(doc_id, other_id, model$dtm, vectors, top_n = 5)
          
          if (!is.null(scm_breakdown) && nrow(scm_breakdown) > 0) {
            # Format: "protest <-> riot (0.82)"
            pairs_str <- paste(
              sprintf("%s (%.2f)", scm_breakdown$Pair, scm_breakdown$Sim), 
              collapse = ", "
            )
            df$SCM_Drivers[i] <- pairs_str
          } else {
            df$SCM_Drivers[i] <- "(No strong links)"
          }
        } else {
          # Fallback to simple intersection if no vectors
          vec_A <- model$dtm[doc_id, , drop=FALSE]
          vec_B <- model$dtm[other_id, , drop=FALSE]
          common <- intersect(names(which(vec_A[1,]>0)), names(which(vec_B[1,]>0)))
          df$SCM_Drivers[i] <- paste(head(common, 5), collapse = ", ")
        }
      } else {
        df$SCM_Drivers[i] <- "-"
      }
    }
    
    return(df)
  }, striped = TRUE, hover = TRUE, width = "100%")
  
  observeEvent(input$sel_node, {
    # If user selects nodes, ensure the Workbench is visible
    # But don't force switch if they are reading text.
    # Actually, simpler: just let them switch manually, but default to Workbench?
    # Let's auto-switch to "Selection Workbench" only if they select > 1 node
    if (length(input$sel_node) > 1) {
      updateTabsetPanel(session, "workbench_tabs", selected = "Selection Workbench")
    }
  })
  
  # --- E. DOC INSPECTOR (REFACTORED) ---
  
  # 1. Determine "Focused" Document
  # This Logic: If multiple nodes are selected, use the Dropdown value. 
  # If the Dropdown is invalid (e.g., old selection), default to the first node.
  focused_doc_id <- reactive({
    req(input$sel_node)
    current_selection <- input$sel_node
    
    # Check if the user has selected a specific doc in the dropdown
    if (isTruthy(input$inspector_dropdown) && 
        input$inspector_dropdown %in% current_selection) {
      return(input$inspector_dropdown)
    }
    
    # Default: Return the first selected node
    return(current_selection[1])
  })
  
  # 2. Render the Header (Title vs Dropdown)
  output$inspector_header <- renderUI({
    req(input$sel_node)
    selection <- input$sel_node
    
    if (length(selection) > 1) {
      # Show a dropdown to switch between docs
      selectInput("inspector_dropdown", "Inspecting Document:", 
                  choices = selection, 
                  selected = focused_doc_id())
    } else {
      # Just show the title
      tagList(
        h4("Document Viewer"),
        h3(selection[1])
      )
    }
  })
  
  # 3. Render the Text (LIVE UPDATES)
  current_html_content <- reactive({
    req(focused_doc_id())
    doc_id <- focused_doc_id()
    
    # Safety Check
    if (!doc_id %in% names(model$full_text)) return("<h4>Doc ID not found.</h4>")
    
    # Get Content
    raw <- model$full_text[doc_id]
    doc_terms <- names(which(model$dtm[doc_id,] > 0))
    
    # Build Highlight Groups
    groups <- list()
    
    # Layer 1: Search Query
    if ("query" %in% input$highlights && isTruthy(input$search_term)) {
      groups$query <- c(input$search_term)
    }
    
    # Layer 2: Bursty Words
    if ("bursty" %in% input$highlights) {
      top_bursty <- model$stats %>% 
        filter(Term %in% doc_terms) %>%
        arrange(Entropy_Gap) %>% 
        head(20) %>%
        pull(Term)
      groups$bursty <- top_bursty
    }
    
    # Layer 3: Shared Terms (Edge Composition)
    if ("shared" %in% input$highlights && length(input$sel_node) > 1) {
      current_doc <- doc_id
      other_docs <- setdiff(input$sel_node, current_doc)
      
      # Intersection Logic
      vec_current <- model$dtm[current_doc, , drop=FALSE]
      terms_current <- names(which(vec_current[1, ] > 0))
      
      vec_others <- model$dtm[other_docs, , drop=FALSE]
      if (length(other_docs) > 1) {
        counts_others <- Matrix::colSums(vec_others)
        terms_others <- names(which(counts_others > 0))
      } else {
        terms_others <- names(which(vec_others[1, ] > 0))
      }
      
      common_terms <- intersect(terms_current, terms_others)
      if (length(common_terms) > 0) groups$shared <- common_terms
    }
    
    # Generate HTML
    if(exists("highlight_fruit_salad")) {
      final_html <- highlight_fruit_salad(raw, groups)
      # Convert newlines to breaks for display
      return(gsub("\n", "<br>", final_html))
    } else {
      return("<b style='color:red'>Error: Highlighter function not found.</b>")
    }
  })
  
  # --- 2. OUTPUT: Render the Text to Screen ---
  output$doc_viewer <- renderUI({
    # Simply call the reactive
    HTML(current_html_content())
  })
  
  # --- 3. OUTPUT: Handle the Download ---
  output$download_transcript <- downloadHandler(
    filename = function() { paste0("transcript_", focused_doc_id(), ".html") },
    content = function(file) {
      # Construct the standalone HTML file
      full_html <- paste0(
        "<html><head><style>", fruit_salad_css, 
        "</style><style>body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; line-height: 1.6; }</style>",
        "</head><body>",
        "<h3>Document ID: ", focused_doc_id(), "</h3>",
        current_html_content(), # <--- Calls the same reactive!
        "</body></html>"
      )
      writeLines(full_html, file)
    }
  )
}

shinyApp(ui, server)